# ODM: Object Document Mdel
ODM is similar to ORM, but it is specifically designed for working with NoSQL databases, particularly document-oriented databases like MongoDB, CouchDB, Amazon DynamoDB,etc. While ORM is used to map objects in object-oriented programming to relational database tables, ODM maps objects to documents in a document database.

# Advantages of ODM

## Simplicity and Abstraction:

ODM provides a simplified interface for interacting with document databases, allowing developers to work with native objects rather than writing complex queries.

## Schema Flexibility:

Document databases allow for dynamic schemas, meaning documents in the same collection can have different structures. ODMs can easily accommodate this flexibility.

## Reduced Development Time:

By abstracting the database interactions, ODMs can speed up development time as developers can focus on building application logic instead of handling raw database queries.

# Disadvatages of ORM

## Performance Overhead:
The abstraction layer introduced by ODM can add performance overhead, especially for complex queries that may be more efficiently executed in raw database queries.

## Limited Query Capabilities:
ODMs may not expose all the features of the underlying database, limiting the ability to perform advanced queries or optimizations.

## Dependency on ODM Framework:
Applications become dependent on the specific ODM framework, which may lead to challenges in migrating to other databases or frameworks in the future.

## Mongoose
Mongoose is popular ODM for mongodb

## Defining Schema
mongoose.Schema(...): This creates a new schema object.
The schema defines the structure of the documents in the uers collection.

```
const userSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,  // This field is required
    },
    email: {
        type: String,
        required: true,
        unique: true, // This ensures email addresses are unique
    },
    age: {
        type: Number,
        min: 0, // Minimum value for age
    },
    createdAt: {
        type: Date,
        default: Date.now, // Default value for createdAt is the current date
    },
});
```

## Cretaing the model

```
const User = mongoose.model('Model_Name', userSchema);
```
The mongoose.model function creates a model based on a given schema. A model is essentially a JavaScript class that allows you to interact with a specific collection in the MongoDB database.

When you call mongoose.model('ModelName', schema), you specify the name of the model (ModelName) and the schema it should use (schema). Mongoose uses this model name to determine which MongoDB collection to interact with.

The collection name is usually derived from the model name by converting it to lowercase and pluralizing it (e.g., the model name User corresponds to the collection users).

The model generated by mongoose.model comes with built-in methods that facilitate CRUD (Create, Read, Update, Delete) operations. For instance, you can use methods like:
.create(): To create a new document.
.find(): To retrieve documents from the collection.
.findById(): To find a document by its ID.

# How to increase Efficcinecy of ODM

## Using Lazy Loading
```
const user = await User.findById(userId); // Fetch user
const posts = await user.populate('posts'); // Load posts only when needed
```

## Batch Operations
```
Perform bulk inserts/updates to minimize database round trips.
await User.insertMany([
  { name: 'Alice' },
  { name: 'Bob' },
  { name: 'Charlie' },
]); // Insert multiple users at once
```

## N+1 Query Problem
Suppose you have a database of Users and each user has multiple Posts. If you retrieve a list of users and then, for each user, make a separate query to fetch their posts, you will end up with N+1 queries.

```
// Fetch users (1 query)
const users = await User.find();

// For each user, fetch their posts (N queries)
for (const user of users) {
    const posts = await user.getPosts(); // This results in additional N queries
}

```

## To avoid the N+1 query problem, you can use eager loading to fetch the related data in a single query, which drastically reduces the number of database calls.

// Use eager loading to fetch users and their posts in one query
const users = await User.find().populate('posts'); // This only makes 1 query

The populate('posts') method tells Mongoose to look for the IDs in the posts array of the user document and fetch the actual post documents from the posts collection. The resulting user object will include all the post documents in place of their IDs.

## Indexing
Setting index: true in Mongoose schemas helps optimize the performance of your MongoDB queries. It allows MongoDB to quickly access records based on the indexed fields, resulting in faster data retrieval times, reduced latency, and improved overall application performance.